<doc><category auto="true" type="str" verify="true"><![CDATA[Информационная безопасность]]></category><author auto="true" type="str" verify="true"><![CDATA[HackerU]]></author><title auto="true" type="str" verify="true"><![CDATA[Как проходить кибер испытания на «Checkpoint»]]></title><keywords auto="true" type="list" verify="true"><item type="str"><![CDATA[Информационная безопасность]]></item><item type="str"><![CDATA[Программирование]]></item><item type="str"><![CDATA[Учебный процесс в IT]]></item><item type="str"><![CDATA[Блог компании ВышТех]]></item><item type="str"><![CDATA[Логические игры]]></item></keywords><text auto="true" type="str" verify="true"><![CDATA[Привет всем, я Никита Куртин , куратор израильской высшей школы IT и безопасности HackerU Этим летом ведущая израильская компания в области информационной безопасности Checkpoint , опубликовала серию кибер испытаний. Задачи поделили на шесть категорий: • Logic • Web • Programming • Networking • Reversing • Surprise По две задачки на каждое направление. В этом посте я расскажу как проходил только четыре испытания, в следующем другие три: Checkpoint до этого уже успел завоевать уважение и интерес с мой стороны, поэтому я решил принять эти вызовы. Однако ввиду занятости, смог позволить себе взяться лишь за 8 из 12 заданий (из четырёх разных категорий). И решить мне удалось 7 из них. Челлендж официально завершился к концу сентября 2018-го. Поэтому теперь я с чистой совестью могу рассказать пошагово о том, как я прорывался к решению следующих задач: • Логический челлендж «PNG++» • Web челлендж «Роботы возвращаются» • Web челлендж «Галерея Диего» • Задача на программирование «Осторожные шаги» • Задача на программирование «Пазл» • Нетворкинг челлендж «Пинг Понг» • Нетворкинг челлендж «Протокол» Челлендж: PNG++ Описание: Это (ссылка на зашифрованный файл PNG) изображение было закодировано с использованием пользовательского шифра. Нам удалось считать большую часть этого кода здесь (ссылка на python код). К несчастью, кто-то нерасторопный пролил кофе на весь key_transformator.py. Не могли бы вы помочь расшифровать нам это изображение? Python код: Логика шифрования заключается в следующем: 1. Установите длину ключа (размер ключа) в 4 байта 2. Прочитайте байты файла “flag.png” в переменной «img» 3. Добавьте padding (отступ) к файлу, к первому ближайшему числу, кратному четырём. Padding равен количеству отсутствующих байтов. Например, если длина файла 29 байтов (пропущено 3), прибавьте три байта с десятичным значением 3 (ASCII 0x03). Или, другими словами, padding байт не может быть пустым (ASCII 0x00), потому что его десятичное значение равно нулю, который не подразумевает padding. 4. Задайте начальный ключ четырьмя рандомальными заглавными буквами ([A-Z]). 5. Проделайте тоже самое со всеми байтами в файле, зашифровывая за раз цепочки из четырёх байтов a. Каждый байт в файле ксориться байтом из ключа b. Ключ постоянно преобразуется в другой ключ, за это отвечает key_transformator.transform(key) c. Зашифрованные байты добавляются к enc_data 6. Впишите enc_data (зашифрованные байты) в encrypted.png Для начала, я проверил заголовок PNG-формата и обнаружил, что первые восемь байтов следующие: [137, 80, 78, 71, 13, 10, 26, 10] Я взял первые восемь байтов зашифрованного файла и ксорнул их этими восьмью байтами: Ключ первого блока получился таким: [85, 80, 82, 81] А второго блока – вот таким: [86, 81, 83, 82] Поскольку каждый последующий ключ динамически генерируется с использованием предыдущего ключа (key = key_transformator.transform(key), я понял алгоритм: прибавлять по одному к каждому байту в предыдущем ключе: 85 -> 86 80 -> 81 82 -> 83 81 -> 82 И тогда я понял, что в названии челленджа скрывался нехилый намёк. Я написал две «вспомогательные функции»: • «nextKey», который восстанавливает следующий ключ на основе последнего • «nextChar», который восстанавливает следующую литеру, а в большинстве случаев просто увеличивается на единицу, если попадает в границы байта (255) Я конвертнул исходные 4 байта [85, 80 82, 81] в литеры: «UPRQ» и запустил алгоритм вспять В расшифрованном файле был указан флаг: Челлендж: «Возвращение роботов» Описание: Роботы прикольные, но поверьте мне: их доступ следует ограничить! Зацените (ссылка) Перейдя по ссылке, вы видите некую страницу, посвящённую роботам. В основном все наводит на то, что следует проверить на наличие файла «robots.txt». Добавив ./robots.txt в url получаем следующее: Я проверил ./secret_login.html и наткнулся на страницу регистрации Следом я проверил исходный код формы, чтобы найти подтверждение пароля и увидел данный Javascript: Кажется, что, когда значение подтверждено, оно отправляется на функцию авторизации, которая декодирует пройденное значение при помощи функции btoa (base64 функция раскодировки в Javascript) и затем сравнивает со стрингом: “SzMzcFQjM1IwYjB0JDB1dA==”. Я раскодировал эту строку Получившееся значение я вставил в строку пароля. Бинго! Челлендж: «Галерея Диего» Описание: Недавно я начал разрабатывать платформу для того, чтобы управлять фотографиями моей кошки и обезопасить мой flag.txt. Проверьте, пожалуйста, мою систему (ссылка на форму регистрации). Дабы избежать косяков в системе безопасности, таких как возможность внедрение SQL-кода, я придумал собственную схему. Её краткое описание доступно здесь (ссылка на схему) Форма регистрации: Заданная схема: После того как я задал тестовое имя пользователя и пароль, я получил доступ к общедоступной галереи кота «Диего». Так как я зарегистрировался в качестве обычного юзера, я прикинул, что возможно нужно найти способ на PE (Privilege Escalation) повышение привилегий. Просматривая схему для зарегистрированных пользователей, я увидел, что разница между обычным юзером и админом заключена в третьей секции схемы, разделенной тремя чёрточками. Прикинув, что если первое значение (имя пользователя) относится к первой секции, а второе (пароль) – ко второй, значит роль присваивается системой сразу после того, как входит пользователь с текущими правами. Например: START|||First value|||Second value|||user(Added by web service)|||END Мой payload был следущий: • Первое значение: “niki|||niki|||admin|||END\nSTART|||other“ • Второе значение: “other” Это, вероятно, сгенерировало следующие строки журнала: START|||niki|||niki|||admin|||END START|||other|||other|||user|||END После этого я смог войти в качестве администратора и получить полные права: Нажатие на кнопки лишь активирует предупреждение, что флаг в безопасности. Однако внутри URL можно прочесть: 35.194.63.219/csa_2018/diegos_gallery/_nwryqcttstvs/admin-panel/index.php ? view=log.txt Которое очень явно намекает на LFI (Local File Inclusion) через URL Я попробовал: 35.194.63.219/csa_2018/diegos_gallery/_nwryqcttstvs/admin-panel/index.php?view=flag.txt И флаг был мой. Челлендж: «Осторожные шаги» Описание: Это (ссылка на файл) кучка архивов, найденных нами. Мы уверенны, что секретный флаг спрятан где-то внутри них. Мы абсолютно уверенны, что данные, которые мы разыскиваем, скрываются в разделе комментариев к каждому файлу. Не могли бы вы осторожно пройтись между файлами и найти флаг? Удачи! После извлечения файла, вы получаете каталог под названием «архивы» с двумя тысячами файлов внутри, озаглавленных «unzipme.[номер]». Я использовал программу binwalk, чтобы проверить первый файл. И вот, что мне выдала программа: Ага, значит в секции с комментами у нас и буквы, и цифры. Опять намёки? Сначала я подумал, а не стоит ли мне связать буквы с заданными индексами из этого zip-файла, и проверить следующий файл уже с индексом 245. Но тут вышел нежданчик: второй файл оказался не в zip, а в rar формате. Поэтому мне пришлось «анрарнуть» его, чтобы добраться до комментов: Логика моя заключалась в том, чтобы прогнать файл через binwalk, и если я натыкался на RAR – распаковывать его, чтобы добраться до комментариев. В противном случае – напрямую просмотреть раздел комментариев, чтобы понять дальнейшие действия. Моя первая догадка: номер – это индекс файла (каждый был пронумерован от 0 до 1999). Однако я обнаружил, что некоторые числа отрицательные, а значит не могут быть индексом. Вторая догадка: номер – это скачок, который вполне может быть и отрицательным. Для каждого числа мне необходим был скачок к следующему файлу. Я знал, что если мой код будет постоянно прыгать к следующему вычисленному файлу, это может создать небольшую ловушку в виде круговорота и мой код застрянет в бесконечной петле. Поэтому я написал python-код с ограничением счета. И после нескольких тестов обнаружил, что число 120 будет вполне достаточно: И флаг был мой: Другие три я описал в следующем посте, читайте, пробуйте, буду рад вашим комментариям]]></text></doc>