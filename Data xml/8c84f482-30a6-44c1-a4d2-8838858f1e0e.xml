<doc><category auto="true" type="str" verify="true"><![CDATA[Информационная безопасность]]></category><author auto="true" type="str" verify="true"><![CDATA[zuart]]></author><title auto="true" type="str" verify="true"><![CDATA[Уведомления о входах на сервер (SSH/TERMINAL) дешево и сердито]]></title><keywords auto="true" type="list" verify="true"><item type="str"><![CDATA[Информационная безопасность]]></item><item type="str"><![CDATA[Системное администрирование]]></item><item type="str"><![CDATA[*nix]]></item></keywords><text auto="true" type="str" verify="true"><![CDATA[Приветствую сообщество. Это первая публикация, далеко не профи-администратора, но просто захотелось поделиться короткой и простой наработкой, которая может оказаться полезной для такого же новичка как я сам. Сложилось так, что потребовалось контролировать около 30 VDS-ок на Debian, которые мне благополучно «передали» под надзор (а я как бы больше программист, чем *nix-администратор). И первая мысль, что пришла в голову после базовых операций по смене и проверке доступов, была «Если я что-то упустил, хочу оперативно знать о подключениях». Есть рецепты (в том числе на Хабре) связывания события авторизации по SSH и почтовых уведомлений, которые я использовал как базу, но мне хотелось все-таки оперативности и некоторой информативности. В общем получил я в итоге вот такую «систему», которая в течение месяца вполне успешно работает и сообщает мне о любом факте авторизации. С помощью мануалов по API-телеграм получен токен и чат-ид для бота уведомлений (тут распространяться не буду, это все легко и просто находится в 1-2 строке поисковика). Создано два скрипта, код от которых будет размещен ниже. В принципе можно все сунуть и в один файл, но т.к. я хотел модульности, то я вынес в отдельный скрипт функцию отправки уведомления в телеграм-бота. В два файла настроек добавил вызов скрипта регистрации события входа на сервер и перезапустил службу SSH. На все про все уходит минут 5-10, не больше. Ну а теперь собственно техничка. PS. Все выполнялось на Debian9 x 64 (если это важно). /sbin/onlogged #!/bin/sh if [ " $1 " = "ssh" ] && [ -z " $TERM " ] ; then MESS= "USER USE SSH AUTH [not console]" elif [ " $1 " = "bash" ] && [ ! -z " $TERM " ] ; then if [ ! -z " $SUDO_USER " ] && [ " $TERM " = "linux" ] ; then MESS= "USER USE SUDO DISPLAY CONSOLE [terminal]" elif [ ! -z " $SUDO_USER " ] && [ ! " $TERM " = "linux" ] ; then MESS= "USER USE SUDO SSH CONSOLE [ssh session]" elif [ " $TERM " = "linux" ] ; then MESS= "USER USE DISPLAY CONSOLE [terminal]" elif [ ! -z " $SSH_TTY " ] ; then MESS= "USER USE SSH CONSOLE [ssh session]" else MESS= "USER LOGGED [unknown]" fi fi if [ ! -z " $MESS " ] ; then if [ ! -z " $SSH_TTY " ] ; then M_TTY= " TTY = $SSH_TTY |" fi if [ ! -z " $SUDO_USER " ] ; then M_SUDO= " SUDO = $SUDO_USER |" fi if [ ! -z " $TERM " ] ; then M_TERM= " TERM = $TERM |" fi SEND= " $MESS | USER = $USER | $M_TTY $M_SUDO $M_TERM " /sbin/telegram " $SEND " "ALERT" > /dev/null fi /sbin/telegram #!/bin/sh if [ $# -gt 0 ] then text= "[ $2 ] `cat /etc/hostname` : $1 " url= "https://api.telegram.org/bot{TOKEN}/sendMessage" curl \ --data-urlencode "chat_id={CHAT_ID}" \ --data-urlencode "text= $text " \ --connect-timeout 10 \ --max-time 10 \ $url > /dev/null 2>&1 else echo "Text is empty" fi /etc/ssh/sshrc /sbin/onlogged ssh /etc/bash.bashrc ... тут весь текущий код .../sbin/onlogged bash Возможно, это все банально и просто, но кому-то будет интересным или просто базой для создания чего-то своего.]]></text></doc>