<doc><category auto="true" type="str" verify="true"><![CDATA[Информационная безопасность]]></category><author auto="true" type="str" verify="true"><![CDATA[artdeepitech]]></author><title auto="true" type="str" verify="true"><![CDATA[Основы повышения привилегий в Windows]]></title><keywords auto="true" type="list" verify="true"><item type="str"><![CDATA[Информационная безопасность]]></item></keywords><text auto="true" type="str" verify="true"><![CDATA[Решил для себя и для тех, кому будет полезно, собрать все что знаю, но не помню по теме, в этой статье. Делитесь советами. Основным источником этой статьи является эта . Я вольно перевел и добавил немного от себя, того, что насобирал и узнал из других источников. В общем, тут представлены способы, которые помогут нам достигнуть цели повышения привилегий. Отправной точкой для этой небольшой статьи является непривилегированная оболочка (учетная запись). Возможно, мы использовали эксплойт или провели атаку и получили эту оболочку. В принципе, в начальный момент времени мы не понимаем машину: что она делает, к чему она подключена, какой уровень привилегий у нас есть или даже какая это операционная система. Сначала нам нужно получить нужную нам информацию, чтобы понять, где мы вообще находимся и что имеем: systeminfo | findstr /B /C: "Название ОС" /C: "Версия ОС" Эта команда позволяет определить, как из нее видно, Название и версию ОС. Можно выполнить ее и без параметров, тогда вывод команды будет более полным, но нам достаточно и этого. Далее важно узнать имя машины и имя пользователя, под которым мы подключились. hostname — имя пользователя. echo %username% — имя пользователя. Далее посмотрим, какие пользователи есть еще на данном хосте и получим более подробную информацию о своем пользователе. net users — другие пользователи net user user1 — детальная информация по пользователю, где user1 — имя вашего пользователя. Получив информацию об учетке, посмотрим информацию о сетевом взаимодействии данного хоста. Сначала глянем на имеющиеся интерфейсы и таблицу маршрутизации. ipconfig /all — информация об имеющихся интерфейсах. route print — таблица маршрутизации arp -A — таблица arp записей Далее посмотрим активные сетевые подключения и правила брандмауэра. netstat -ano — активные сетевые подключения. -a — запуск с данным параметром выведет на экран все активные подключения TCP, а также порты TCP и UDP, прослушиваемые системой; -n — параметр позволяет показать активные подключения TCP с адресами и номерами портов; -o — так же, как и предыдущий ключ, выводит активные TCP подключения, но в статистику добавлены коды процессов, по ним уже можно точно определить, какое именно приложение использует подключение. netsh firewall show state — статус брандмауэра netsh firewall show config — конфигурация брандмауэра Наконец, мы кратко рассмотрим, что работает на скомпрометированном хосте: запланированные задачи, запущенные процессы, запущенные службы и установленные драйверы. schtasks /query /fo LIST /v где /query — Вывод данных о всех запланированных задачах, /fo LIST — Вывод в список. /v — Вывод подробных сведений о задании. Следующая команда связывает запущенные процессы с запущенными службами. tasklist /SVC где, /SVC — Отображение служб для каждого процесса. Также посмотрим список запущенных служб Windows. net start Полезно также посмотреть информацию о драйверах скомпрометированной системы. DRIVERQUERY Далее хочется упомянуть о, наверное, самой полезной команде Windows — wmic. Команда WMIC (Windows Management Instrumentation Command) используется для получения сведений об оборудовании и системе, управления процессами и их компонентами, а также изменения настроек с использованием возможностей инструментария управления Windows (Windows Management Instrumentation или WMI). Хорошее описание . К сожалению, некоторые конфигурации Windows по умолчанию не разрешают доступ к WMIC, если пользователь не входит в группу Администраторов (что действительно хорошая идея). Любая версия XP не позволяла доступ к WMIC с непривилегированной учетной записи. Напротив, Windows 7 Professional и Windows 8 Enterprise по умолчанию позволяли пользователям с низкими привилегиями использовать WMIC. По обычаю — параметры программы: wmic /? Хороший скрипт по сбору инфы через wmic. Прежде чем идти дальше стоит пробежаться по собранной информации. Также стоит обратить внимание на установленные в системе патчи, так как любая информация о дырах в системе даст нам дополнительную опору для повышения своих привилегий. По номеру HotFix можно поискать уязвимости по повышению привилегий. Далее мы рассмотрим автоматическую установку. Если существует необходимость установки и настройки большого парка машин, то как правило, технический персонал не будет перемещаться от машины к машине для настройки персонального каждой. Существует несколько решений для автоматической установки. Для нас не так важно, что это за методы и как они работают, а важно то, что они оставляют конфигурационные файлы, которые используются для процесса установки, содержащие много конфиденциальной информации, такой как ключ продукта операционной системы и пароль администратора. Что нас больше всего интересует, так это пароль администратора, который мы можем использовать для повышения наших привилегий. Как правило, это следующие каталоги: c:\sysprep.inf c:\sysprep\sysprep.xml %WINDIR%\Panther\Unattend\Unattended.xml %WINDIR%\Panther\Unattended.xml Но стоит проверить и всю систему. Данные файлы содержат пароли в открытом виде или кодировке BASE64. Примеры: Sysprep.inf — пароль в открытом виде. " Sysprep.xml — пароль в кодировке base64. " Unattended.xml — пароль в кодировке base64. Также для хостов, подключенных к домену можно поискать файл Group.xml, который содержит зашифрованный AES256 пароль, но который можно расшифровать, т.к. ключ выложен на msdn (https://msdn.microsoft.com/en-us/library/cc422924.aspx) и других источниках. Но это в случае, если используется политика создания локальных пользователей на хостах или, например, задании пароля локальному Администратору. Например, у меня лежит тут: Открыв его, ищем параметр “cpassword”. Далее нужно расшифровать данную последовательность. Используем, например, CrypTool . Сначала раскодируем Base64. Особенности Base64 в том, что его длина должна быть кратна 4. Поэтому считаем блоки по 4, и если в последнем блоке не хватает символов, то недостающие дописываем символами «=». У меня вышло 2 «=». Далее расшифруем. Применяя тот ключ, что выше. Убираем лишние точки, разделяющие знаки и получаем пароль. В дополнение к Group.xml вот несколько других файлов предпочтений политики, которые могут иметь дополнительный набор атрибутов «cPassword”: Services\Services.xml ScheduledTasks\ScheduledTasks.xml Printers\Printers.xml Drives\Drives.xml DataSources\DataSources.xml Однако мы все любим автоматизированные решения, поэтому мы можем добраться до финиша как можно быстрее. Здесь есть два основных варианта, в зависимости от типа оболочки/доступа, который у нас есть. Существует модуль metasploit, который может быть выполнен через установленную сессию (https://www.rapid7.com/db/modules/post/windows/gather/credentials/gpp) или Вы можете использовать Get-GPPPassword, который является частью PowerSploit . Ладно, дальше. Будем искать странный параметр реестра „AlwaysInstallElevated“. Данный параметр разрешает непривилегированным пользователям устанавливать .msi файлы из-под NT AUTHORITY\SYSTEM. Для того, чтобы иметь возможность использовать это, мы должны проверить, что оба раздела реестра установлены, и если это так, мы можем получить SYSTEM shell. Проверим: reg query HKLM \ SOFTWARE \ Policies \ Microsoft \ Windows \ Installer \ AlwaysInstallElevated reg query HKCU \ SOFTWARE \ Policies \ Microsoft \ Windows \ Installer \ AlwaysInstallElevated В состав Metasploit входит специальный модуль exploit/windows/local/always_install_elevated, который создает MSI-файл со встроенным в него специальным исполняемым файлом, который извлекается и выполняется установщиком с привилегиями системы. После его выполнения msi-файл прекращает установку, чтобы предотвратить регистрацию действия в системе. К тому же если запустить установку с ключом /quiet, то даже не выведется ошибка. Ну и немного полезных команд по поиску по системе: Команда ниже будет искать в файловой системе имена файлов, содержащие определенные ключевые слова. Вы можете указать любое количество ключевых слов. dir /s *pass* == *cred* == *vnc* == *.config* Поиск определенных типов файлов по ключевому слову, эта команда может генерировать много выходных данных. findstr /si password *.xml *.ini *.txt Аналогично две команды ниже могут быть использованы для grep реестра по ключевым словам, в данном случае „password“. reg query HKLM /f password /t REG_SZ /s reg query HKCU /f password /t REG_SZ /s На данный момент у нас уже есть достаточно, чтобы получить системный шел. Но есть еще пара направленbй атаки для получения желаемого результата: мы рассмотрим службы Windows и разрешения для файлов и папок. Наша цель здесь — использовать слабые разрешения для повышения привилегий сеанса. Мы будем проверять много прав доступа, в этом нам поможет accesschk.exe, который является инструментом от Microsoft Sysinternals Suite. Microsoft Sysinternals содержит много отличных инструментов. Пакет можно загрузить с сайта Microsoft technet (https://docs.microsoft.com/ru-ru/sysinternals/downloads/sysinternals-suite). Мы можем проверить необходимый уровень привилегий для каждой службы с помощью accesschk. Мы можем видеть разрешения, которые имеет каждый уровень пользователя. Accesschk может автоматически проверять, есть ли у нас доступ на запись к службе Windows с определенным уровнем пользователя. Как правило, как пользователь с низкими привилегиями, мы хотим проверить „Пользователей“. Удостоверьтесь, что проверили, к каким группам пользователей вы принадлежите. -c В качестве имени указана служба Windows, например ssdpsrv (укажите “*” для вывода на экран всех служб) -d Обрабатывать только каталоги -e Выводить только явным образом заданные уровни целостности (только для ОС Windows Vista) -k В качестве имени указан раздел реестра, например hklm\software -n Выводить только объекты, не имеющие правил доступа -p В качестве имени указано имя или идентификатор процесса (PID), например cmd.exe (укажите в качестве имени “*”, чтобы вывести на экран все процессы) -q Опустить заголовок -r Выводить только объекты, к которым есть право доступа на чтение -s Рекурсивная обработка -v Выводить подробную информацию -w Выводить только объекты, к которым есть право доступа на запись Также есть еще одна интересная команда: autorunsc.exe -a | findstr /n /R "File\ not \ found" Позволяет найти запись в реестре о файле, который запускался автоматически, но сейчас уже отсутствует в системе. Запись могла остаться, если например, сервис был неправильно удален. При каждом запуске система безуспешно пытается запустить этот файл. Этой ситуацией также можно воспользоваться для расширения своих полномочий. Просто на место этого файла можно подставить наш. Далее рассмотрим две уязвимости: Первая: реплицируем результаты поста, написанного Parvez из GreyHatHacker; „Elevating privileges by exploiting weak folder permissions“ (http://www.greyhathacker.net/?p=738). Этот пример является частным случаем угона dll. Программы обычно не могут функционировать сами по себе, у них есть много ресурсов, которые им нужно подключить (в основном dll, но и собственные файлы). Если программа или служба загружает файл из каталога, к которому у нас есть доступ на запись, мы можем злоупотребить этим, чтобы запустить оболочку с привилегиями, под которыми работает программа. Как правило, приложение Windows будет использовать предопределенные пути поиска, чтобы найти dll, и он будет проверять эти пути в определенном порядке. Dll угон обычно происходит путем размещения вредоносных dll по одному из этих путей. Эта проблема может быть устранена путем указания приложению абсолютных путей к необходимой dll. Порядок поиска dll: Директория с которой запущено приложение 32-bit System directory (C:\Windows\System32) 16-bit System directory (C:\Windows\System) Windows directory (C:\Windows) Действующая рабочая директория (CWD) Directories in the PATH environment variable (system then user) Иногда приложения пытаются загрузить dll файлы, отсутствующие на машине. Это может произойти по нескольким причинам, например, если библиотека dll требуется только для определенных подключаемых модулей или компонентов, которые не установлены. В этом случае Parvez обнаружил, что некоторые службы Windows пытаются загрузить библиотеки dll, которые не существуют в установках по умолчанию. Так как dll не существует, мы в конечном итоге прохождения всех путей поиска. Как пользователь с низким уровнем привилегий у нас немного шансов положить вредоносный dll в п. 1-4, 5. Но если у нас есть доступ на запись в любой из каталогов, то наши шансы на победу велики. Давайте посмотрим, как это работает на практике, для нашего примера мы будем использовать IKEEXT (модули ключей IPSec IKE и AuthIP) сервис, который пытается загрузить wlbsctrl.dll. Любой каталог в „C:\“ даст доступ на запись для аутентифицированных пользователей, это дает нам шанс. C: \ Users \ user 1 \ Desktop > accesschk.exe -dqv "C: \ Python 27" C:\Python27 Medium Mandatory Level ( Default ) [ No - Write -Up] RW BUILTIN\Administrators FILE_ALL_ACCESS RW NT AUTHORITY\ SYSTEM FILE_ALL_ACCESS R BUILTIN\Users FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE SYNCHRONIZE READ_CONTROL RW NT AUTHORITY\Authenticated Users FILE_ADD_FILE FILE_ADD_SUBDIRECTORY FILE_LIST_DIRECTORY FILE_READ_ATTRIBUTES FILE_READ_EA FILE_TRAVERSE FILE_WRITE_ATTRIBUTES FILE_WRITE_EA DELETE SYNCHRONIZE READ_CONTROL C: \ Users \ user 1 \ Desktop > icacls "C: \ Python 27" C: \ Python 27 BUILTIN \ Administrators :(ID)F BUILTIN \ Administrators :(OI)(CI)(IO)(ID)F NT AUTHORITY \ SYSTEM :(ID)F NT AUTHORITY \ SYSTEM :(OI)(CI)(IO)(ID)F BUILTIN \ Users :(OI)(CI)(ID)R NT AUTHORITY \ Authenticated Users:(ID)C NT AUTHORITY \ Authenticated Users:(OI)(CI)(IO)(ID)C F — полный доступ. (OI) — наследование объектами. (CI) — наследование контейнерами. (IO) — только наследование. (NP) — запрет на распространение наследования. (I)- наследование разрешений от родительского контейнера. Прежде чем перейти к действию, необходимо проверить состояние службы IKEEXT. В этом случае мы можем увидеть, что он установлен на „AUTO_START“! sc qc IKEEXT [SC] QueryServiceConfig SUCCESSSERVICE_NAME: IKEEXT TYPE : 20 WIN32_SHARE_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C: \ Windows \ system 32 \ svchost .exe -k netsvcs LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : IKE and AuthIP IPsec Keying Modules DEPENDENCIES : BFE SERVICE_START_NAME : LocalSystem Теперь мы знаем, что у нас есть необходимые условия, и мы можем создать вредоносную dll и перехвата оболочки! Используем Metasploit -> msfvenom, это например. После передачи evil.dll на наш целевой компьютер все, что нам нужно сделать, это переименовать его в wlbsctrl.dll и переместить в „C:\Python27“. Как только это будет сделано, нам нужно терпеливо ждать перезагрузки машины (или мы можем попытаться принудительно перезагрузить), и мы получим системную оболочку. copy evil .dll C :\ Python27 \ wlbsctrl .dll После этого осталось только дождаться перезагрузки системы. Для нашего последнего примера мы рассмотрим запланированные задачи. Опишу принцип, т.к. у всех могут быть разные случаи. Находим процесс, службу, приложение запускаемое планировщиком задач от SYSTEM. Проверяем права доступа на папку, где находится наша цель. accesschk.exe -dqv "путь_к_цели" Ясно, что это серьезная проблема конфигурации, но еще хуже тот факт, что любой прошедший проверку Пользователь (аутентифицированный пользователь) имеет доступ на запись в эту папку. В этом примере мы можем просто перезаписать двоичный исполняемый файл файлом, сгенерированным в metasploit. Можно закодировать дополнительно. Теперь остается только загрузить вредоносный исполняемый файл и перезаписать его в папку выполняемого файла. Как только это будет сделано, мы можем спокойно идти спать и рано с утра получить системный шел. Эти два примера должны дать нам представление об уязвимостях, которые необходимо искать при рассмотрении разрешений для файлов и папок. Потребуется время, чтобы изучить все пути binpath для служб windows, запланированные задачи и задачи автозапуска. Напоследок пара советов по использованию accesschk.exe. Найти все слабые разрешения для папок на диске. accesschk.exe -uwdqs Users c :\accesschk.exe -uwdqs "Authenticated Users" c :\ Найти все слабые разрешения для файлов на диске. accesschk.exe -uwqs Users c :\*.*accesschk.exe -uwqs "Authenticated Users" c :\*.* Вроде всё.]]></text></doc>