<doc><category auto="true" type="str" verify="true"><![CDATA[Информационная безопасность]]></category><author auto="true" type="str" verify="true"><![CDATA[olegator99]]></author><title auto="true" type="str" verify="true"><![CDATA[Как мы научились подключать китайские камеры за 1000р к облаку. Без регистраторов и SMS (и сэкономили миллионы долларов)]]></title><keywords auto="true" type="list" verify="true"><item type="str"><![CDATA[Настройка Linux]]></item><item type="str"><![CDATA[Информационная безопасность]]></item><item type="str"><![CDATA[Работа с видео]]></item><item type="str"><![CDATA[Разработка для интернета вещей]]></item><item type="str"><![CDATA[Интернет вещей]]></item></keywords><text auto="true" type="str" verify="true"><![CDATA[Всем привет! Наверное, ни для кого не секрет, что в последнее время облачные сервисы видеонаблюдения набирают популярность. И понятно почему так происходит, видео — это "тяжелый" контент, для хранения которого необходима инфраструктура и большие объемы дискового хранилища. Использование локальной системы видеонаблюдения требует средств на эксплуатацию и поддержку, как в случае организации, использующей сотни камер наблюдения, так и в случае индивидуального пользователя с несколькими камерами. Облачные системы видеонаблюдения решают эту задачу — предоставляя клиентам уже существующую инфраструктуру хранения и обработки видео. Клиенту облачного видеонаблюдения достаточно просто подключить камеру к интернету и привязать к своему аккаунту в облаке. Есть несколько технологических способов подключения камер к облаку. Бесспорно, наиболее удобный и дешевый способ — камера напрямую подключается и работает с облаком, без участия дополнительного оборудования типа сервера или регистратора. Для этого необходимо, чтобы на камере был установлен модуль ПО работающий с облаком. Однако, если говорить про дешевые камеры, то у них очень ограничены аппаратные ресурсы, которые почти на 100% занимает родная прошивка вендора камеры, а ресурсов необходимых для облачного плагина — нет. Этой проблеме разработчики из ivideon посвятили статью , в которой говорится почему они не могут установить плагин на дешевые камеры. Как итог, минимальная цена камеры — 5000р ($80 долларов) и миллионы потраченных денег на оборудование. Мы эту проблему успешно решили. Если интересно как — велком под кат Немного истории В 2016 году мы стартовали разработку платформы облачного видеонаблюдения для Ростелекома. В части ПО камер на первом этапе пошли "стандартным" для таких задач путем: разработали свой плагин, который устанавливается в штатную прошивку камеры вендора и работает с нашим облаком. Однако, стоит отметить, что при проектировании мы использовали наиболее легковесные и эффективные решения (например, plain C реализацию protobuf, libev, mbedtls и полностью отказались от удобных, но тяжелых библиотек типа boost) Сейчас на рынке IP камер нет универсальных решений по интеграции: у каждого вендора свой способ установки плагина, свой набор API для работы прошивки и уникальный механизм обновления. Это означает, что для каждого вендора камер необходимо индивидуально разрабатывать объемный слой интеграционного ПО. И на момент старта разработки целесообразно работать только с 1-ним вендором, что бы сосредоточить усилия команды на разработке логики работы с облаком. Первым вендором был выбран Hikvision — один из мировых лидеров на рынке камер, предоставляющий хорошо документированное API и грамотную инженерную техническую поддержку. На камерах Hikvision мы и запустили наш первый пилотный проект облачное видеонаблюдение Видеокомфорт. Практически сразу после запуска наши пользователи стали задавать вопросы о возможности подключении к сервису более дешевых камер других производителей. Вариант с реализацией слоя интеграции под каждого вендора я отбросил практически сразу — как плохо масштабируемый и предъявляющий к железу камеры серьезные технические требования. Стоимость камеры, удовлетворяющий таким требованиям на входе: ~60-70$ Поэтому, я принял решение копать глубже — сделать полностью свою прошивку для камер любых вендоров. Этот подход существенно снижает требования к аппаратным ресурсам камеры — т.к. слой работы с облаком на порядок более эффективно интегрирован с video application, и в прошивке нет лишнего не используемого жирка. И что важно, при работе с камерой на низком уровне есть возможность использовать аппаратный AES, который шифрует данные, не создавая дополнительной нагрузки на маломощный CPU. В тот момент у нас не было вообще ничего. Вообще ничего. Практически все вендоры не были готовы работать с нами на таком низком уровне. Информации о схемотехнике и компонентах — нет, официальных SDK чипсетов и документации сенсоров — нет. Технической поддержки так же нет. Ответы на все вопросы приходилось получать реверс инжинирингом — методом проб и ошибок. Но мы справились. Первыми моделями камер, на которых мы набивали шишки стали камеры Xiaomi Yi Ants, Hikvision, Dahua, Spezvision, D-Link и несколько сверх дешевых безымянных китайских камер. Техника Камеры на чипсете Hisilicon 3518E. Аппаратные характеристики камер такие: Xiaomi Yi Ants Noname SoC Hisilicon 3518E Hisilicon 3518E RAM 64MB 64MB FLASH 16MB 8MB WiFi mt7601/bcm43143 - Sensor ov9732 (720p) ov9712 (720p) Ethernet - + MicroSD + + Microphone + + Speaker + + IRLed + + IRCut + + С них мы начинали. Сейчас поддерживаем чипсеты Hisilicon 3516/3518, а так же Ambarella S2L/S2LM. Количество моделей камер — десятки. Состав прошивки uboot uboot — это начальный загрузчик, после включения питания загружается первым, инициализирует оборудование и загружает ядро linux. Скрипт загрузки камеры достаточно тривиален: bootargs=mem= 38 M console=ttyAMA0, 115200 rootfstype=ramfs mtdparts=hi_sfc: 256 K(boot), 64 K(tech), 4096 K(kernel), 8192 K(app),-( config ) hw_type= 101 bootcmd=sf probe 0 ; sf read 0x82000000 0x50000 0x400000 ; bootm 0x82000000 ; setenv bootargs $(bootargs) bkp= 1 ; sf read 0x82000000 0x450000 0x400000 ; bootm 0x82000000 Из особенностей — два раза вызывается bootm , подробнее об этом чуть позже, когда дойдем до подсистемы обновления. Обратите внимание на строчку mem=38M . Да, да, это не опечатка — ядру Linux и всем-всем-всем приложениям доступно всего лишь 38 мегабайт оперативной памяти. Так же рядом с uboot находится специальный блок, называемый reg_info , в котором находится низкоуровневый скрипт инициализации DDR и ряда системных регистров SoC. Содержимое reg_info зависит от модели камеры, и если оно будет не корректным, то камера даже не сможет загрузить uboot, а зависнет на самом раннем этапе загрузки. Первое время, когда мы работали без поддержки вендоров, мы просто копировали этот блок из оригинальной прошивки камеры. Ядро linux и rootfs На камерах используется ядро Linux, входящее в состав SDK чипа, обычно это не самые свежие ядра из ветки 3.x, поэтому часто приходится сталкиваться с тем, что драйвера дополнительного оборудования не совместимы с используемым ядром, и нам приходится их бэк-портировать под ядро камеры. Другая проблема — это размер ядра. Когда размер FLASH всего 8MB, то каждый байт на счет и наша задача — аккуратно отключить все не используемые функции ядра, что бы сократить размер до минимума. Rootfs — это базовая файловая система. В нее включены busybox , драйвера wifi модуля, набор стандартных системных библиотек, типа libld и libc , а так же ПО нашей разработки, отвечающее за логику управления светодиодами, управление сетевыми подключениями и за обновление прошивки. Корневая файловая система подключена к ядру как initramfs и в результате сборки мы получаем один файл uImage , в котором есть и ядро и rootfs. Video application Наиболее сложная и ресурсоемкая часть прошивки — приложение, которое обеспечивает видео-аудио захват, кодирование видео, настраивает параметры картинки, реализует видео-аналитики, например, детекторы движения или звука, управляет PTZ и отвечает за переключения дневного и ночного режимов. Важная, я бы даже сказал ключевая особенность — каким образом видео приложение взаимодействует с облачным плагином. В традиционных решениях 'прошивка вендора + облачный плагин', которые не могут работать на дешевом железе, видео внутри камеры передается по протоколу RTSP — а это огромный оверхед: копирование и передача данных через socket, лишние syscall-ы. Мы в этом месте используем механизм shared memory — видео не копируется и не пересылается через socket между компонентами ПО камеры, тем самым оптимально и бережно используя скромные аппаратные возможности камеры. Подсистема обновления Предмет отдельной гордости — подсистема fault-tolerant онлайн обновления прошивки. Поясню проблематику. Обновление прошивки — это технически не атомарная операция и в случае если посередине обновления произойдет сбой питания, то на флеш памяти будет часть "недозаписанной" новой прошивки. Если не предпринять специальных мер, то камера после этого станет "кирпичом", который нужно нести в сервисный центр. Мы справились и с этой проблемой. Даже если камеру выключить в момент обновления, она автоматически и без участия пользователя скачает прошивку из облака и восстановит работу. Разберем технику подробнее: Наиболее уязвимый момент — перезапись раздела с ядром Linux и корневой файловой системой. В случае, если один из этих компонентов окажется поврежденным, то камера вообще не загрузиться дальше начального загрузчика uboot, который не умеет скачивать прошивку из облака. Значит, нам нужно обеспечить гарантию наличия на камере работоспособного ядра и rootfs в любой момент процесса обновления. Казалось бы самым простым решением было бы постоянно хранить на флеш памяти две копии ядра с rootfs и в случае повреждения основного ядра загружать его из резервной копии. Годное решение — однако, ядро с rootfs занимает около 3.5MB и для постоянной резервной копии нужно выделить 3.5MB. На самых дешевых камерах просто нет столько свободного места под backup ядра. Поэтому для backup ядра во время обновления прошивки используем application партицию. А для выбора нужной партиции с ядром как раз и используется две команды bootm в uboot — в начале пытаемся загрузить основное ядро и если оно повреждено, то резервное. Это гарантирует, что в любой момент времени на камере будет корректное ядро с rootfs, и она сможет загрузиться и восстановить прошивку. CI/CD система сборки и деплоя прошивок Для сборки прошивок мы используем gitlab CI, в котором автоматически собираются прошивки под все поддерживаемые модели камер, после сборки прошивки автоматически деплоятся на сервис обновления ПО камер. Из сервиса обновления ПО прошивки доставляются на тестовые камеры наших QA, а по завершению всех этапов тестирования и на камеры пользователей. Информационная безопасность Ни для кого не секрет, что в наше время информационная безопасность — это важнейший аспект любого IoT устройства, в том числе и камеры. По интернету гуляют ботнеты типа Mirai, поражающие миллионы камер со стандартными прошивками от вендоров. При всем уважении к вендорам камер, не могу не отметить, что в стандартных прошивках заложено много функционала, который не востребован для работы с облаком, однако содержит в себе много уязвимостей, которыми пользуются ботнеты. Поэтому, весь не используемый функционал в нашей прошивке отключен, все tcp/udp порты закрыты и при обновлении прошивки проверяется цифровая подпись ПО. И кроме этого, прошивка проходит регулярное тестирование в лаборатории информационной безопасности. Заключение Сейчас наша прошивка активно используется в проектах по видеонаблюдению. Пожалуй самый масштабный из них — трансляция голосования в день выборов Президента Российской Федерации. В проекте было задействовано более 70 тысяч камер с нашей прошивкой, которые были установлены по избирательным участкам нашей страны. Решив ряд сложных, а местами, даже на тот момент практически невозможных задач, мы, конечно, получили огромное удовлетворение как инженеры, но кроме этого, и сэкономили миллионы долларов на закупке камер. И в данном случае, экономия — это не только слова и теоретические расчёты, а результаты уже случившегося тендера на закупку оборудования. Соответственно, если говорить про облачное видеонаблюдение: есть два подхода — стратегически заложиться на низкоуровневую экспертизу и разработку, получив на выходе огромную экономию на оборудовании или использовать дорогое оборудование, которое, если смотреть именно на потребительские характеристики, практически ничем не отличается от аналогичного дешевого. Почему стратегически важно принять решение относительно выбора подхода к способу интеграции как можно раньше? При разработке плагина, разработчики закладываются на те или иные технологии (библиотеки, протоколы, стандарты). И если выбран набор технологий только под дорогое оборудование, то в дальнейшем попытка перехода на дешевые камеры с большой вероятностью, как минимум, займет безумно большое время или вообще потерпит неудачу и произойдет возврат к дорогому оборудованию.]]></text></doc>