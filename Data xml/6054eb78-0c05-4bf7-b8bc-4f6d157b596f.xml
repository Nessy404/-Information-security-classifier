<doc><category auto="true" type="str" verify="true"><![CDATA[Информационная безопасность]]></category><author auto="true" type="str" verify="true"><![CDATA[hex_none]]></author><title auto="true" type="str" verify="true"><![CDATA[Извлечение мастер-пароля из заблокированного менеджера паролей SafeInCloud]]></title><keywords auto="true" type="list" verify="true"><item type="str"><![CDATA[Информационная безопасность]]></item><item type="str"><![CDATA[Реверс-инжиниринг]]></item><item type="str"><![CDATA[Разработка под Windows]]></item><item type="str"><![CDATA[Софт]]></item></keywords><text auto="true" type="str" verify="true"><![CDATA[После прочтения этой статьи мне захотелось провести исследование другого менеджера паролей на наличие похожих уязвимостей. В комментариях к статье пользователем Dark_Angel был задан вопрос: А что скажите насчет SafeInCloud? Исследование проводилось над бесплатной Windows версией SafeInCloud v.19.0.2 При первом знакомстве с продуктом он произвел на меня очень хорошее впечатление. Однако при дальнейшем исследовании была выявлена точно такая же уязвимость. В отличии от 1Password, SafeInCloud хранит все ваши пароли в открытом виде даже в заблокированном состоянии(после первой разблокировки). Для получения пароля от базы данных достаточно просто прочитать память приложения. Обфускация данных полностью отсутствует! Мастер-пароль(и все остальные пароли и записи) не перезаписывается никогда после первой удачной разблокировки базы данных, даже если пользователь заблокирует её. Ваши пароли могут утечь в случаях: + Отправка отчёта об ошибке в каком-либо ПО. Очень часто разработчики делают дампы памяти всех приложений в целях отладки. + Если пользуетесь компьютером не только Вы. + При получении физического доступа к компьютеру злоумышленников. + При запуске вредоносного ПО. + Возможно попадание содержимого памяти в swap. + Что-нибудь ещё… Приложение под Windows написано на .net, что значительно упрощает анализ исходного кода. Приложение написано на .net После успешной расшифровки базы данных (XDatabase) расшифрованная база и мастер-пароль сохраняются как поля класса в Singleton instanc'е класса DatabaseModel. Установка полей с базой данных и мастер-паролем от неё Все записи и пароли хранятся в памяти в открытом виде даже после блокировки приложения пользователем. Мастер-пароль лежит в открытом виде рядом. Пароль хранится в свойстве Password, _database — поле класса XDatabase, содержащего расшифрованную базу данных. База данных в формате XML. При повторной разблокировке приложение выполняет элементарную проверку: Если пароль, введенный пользователем, совпал с сохраненным в памяти — разблокировка выполнена. Для автоматизации извлечения мастер-пароля была написана простая утилита SafeInCloudExtractor . Утилита выполняет извлечение мастер-пароля и локальный путь к файлу базы данных. А каким менеджером пароля пользуетесь Вы? Напишите в комментариях! UPDATE. После сообщения о наличии проблемы, автор SiC воспринял критику крайне негативно(вплоть до оскорблений). Под давлением пользователей была выпущена бета-версия с «защитой против хакеров». То есть с защитой от утилиты SafeInCloudExtractor. Казалось бы, проблема решена! Пароли «чистятся» из памяти. Однако это не так и вот почему: Обновленная версия SiC также хранит все пароли в памяти. Для усложнения анализа кода был применен обфускатор + добавлена проверка IsDebuggerPresent. Пароли как хранились в открытом виде в памяти, так и хранятся. Похоже, что автор не понимает, от чего нужно защищаться. Вместо того, чтобы исправить проблему, был сделал неработоспособным PoC. Скорее всего, у автора нет необходимой квалификации и знаний, чтобы разрабатывать security-related ПО. Будьте бдительны!]]></text></doc>