<doc><category auto="true" type="str" verify="true"><![CDATA[Информационная безопасность]]></category><author auto="true" type="str" verify="true"><![CDATA[Alyoshka1976]]></author><title auto="true" type="str" verify="true"><![CDATA[ADB vs Spy Cam & Mic]]></title><keywords auto="true" type="list" verify="true"><item type="str"><![CDATA[Информационная безопасность]]></item><item type="str"><![CDATA[Регулярные выражения]]></item><item type="str"><![CDATA[Разработка под Android]]></item><item type="str"><![CDATA[Смартфоны]]></item></keywords><text auto="true" type="str" verify="true"><![CDATA[Как проверить, ведет ли какое-нибудь приложение на Android -смартфоне фото- или видеорепортаж, хотя ему это ни разу ни к чему? Нижепредлагаемый вариант совсем не идеален, но не требует «рута» или кастомной прошивки. P.S. Я добавил в статью описание мониторинга доступа приложений к микрофону. Что требуется установить: ADB ( Android Debug Bridge ) (например, в составе Android SDK Platform Tools — загрузить можно здесь ); драйвер для телефона (при необходимости, например, Google USB Driver можно загрузить здесь ). Включаем на телефоне режим отладки через USB и подключаем смартфон к USB -порту компьютера, причем следует выбрать режим USB -подключения, отличный от «Только зарядка». Скрытый текст В «Диспетчере устройств» смартфон отображается, например, так: в режиме «Фото» или «Файлы» в режиме «USB-диск» А вот так — в выводе команды lsusb : Открываем командную строку в каталоге, в который установились «тулзы». Проверяем, что подключение успешно (отображается серийный номер подключенного смартфона): adb devices (для Windows ) Для Linux команда бы выглядела так: ./adb devices Если компьютер не авторизован для использования с этим смартфоном (под Android 4.2.2 и новее), то рядом с серийным номером появится предупредительное сообщение " unauthorized ". Для авторизации необходимо подтвердить на смартфоне разрешение отладки через USB . Скрытый текст Под Linux может появляться сообщение " no permissions " — в моем случае удалось решить проблему переключением смартфона в режим «Медиаустройство ( MTP )». Запускаем оболочку на устройстве (получаем приглашение "$"): adb shell Затем вводим следующие «магические» символы: while true ; do ps ` while ! (dumpsys media.camera | grep -E "PID" ) do done | grep -o "[^PID: ][0-9]*$" ` | grep -o "[^S ]*$" ; date; sleep 1; done Улучшенный вариант, убирающий вывод «NAME» и пустые строки: while true ; do ps ` while ! (dumpsys media.camera | grep -E "PID" ) do done | grep -o "[^PID: ][0-9]*$" ` | grep -o "[^S ]*$" | grep -v "NAME" | grep .; date; sleep 1; done И ничего не происходит :-) Пока что-то не решит немного поснимать :-) Означенный «магический» набор символов запускает с максимально возможной скоростью мониторинг доступа к сервису камеры — media.camera (этот сервис реализуется библиотекой libcameraservice.so ). Если камера не активна, dumpsys выдает примерно такое: А если камера понадобилась, то появляется такое: grep -ы проверяют наличие " PID " и, если таки эта цепочка есть, то вырезают из строки номер процесса и скармливают его команде ps , которая выводит данные об этом процессе, а еще один grep вырезает его имя. После обнаружения активности камеры делаем паузу на секунду, чтобы сообщения не сыпались слишком часто. Для прерывания работы команды служит комбинация клавиш CTRL-C , а для выхода из оболочки — CTRL-D . Простейший пример — после запуска штатного приложения смартфона для фото/видеосъемки начинают с интервалом в 1 секунду сыпаться сообщения с именем процесса и датой/временем: " Но есть и более хитрые приложения, их можно найти по ключевому слову «spy cam» (использующие трюк, например, с однопиксельным превью ( http://www.ez.ai/2014/05/exploring-limits-of-covert-data.html )). Подобное творение при запуске съемки сворачивается и ведет репортаж, но сообщения сыпятся исправно: Также я проверил работоспособность предложенного метода на приложении, делающем однократный снимок при нажатии на плавающую кнопку без всякого видимого окна предпросмотра. Скрипт успешно отлавливал обращение к камере и выдавал два сообщения при каждом снимке: Но ведь ничто не мешает реализовать подобную функциональность и в приложении с более безобидным названием ( https://www.zdnet.com/article/this-scary-android-malware-can-record-audio-video-and-steal-your-data/ ), а разрешения — ну так случаи всякие бывают. Да и «легальное» приложение может вести репортаж, когда ему заблагорассудится (я встречал упоминание об одном таком случае). И не зря в Android P приняли меры по предотвращению доступа к камере фоновых приложений. Способ проверен на смартфонах Huawei SCL-L01 ( Android 5.1.1) и Huawei G700-U20 ( Android 4.2.1), на других моделях смартфонов формат вывода dumpsys может отличаться (для сервиса media.camera он не стандартизован), что потребует коррекции кода. Формат сообщений жестко «зашит» в библиотеке /system/lib/libcameraservice.so — например, для смартфона Huawei SCL-L01 : В комментарии — подсказка, как изменить код для работы со смартфоном под Android 9. В этом комментарии приводится лог обращений к камере, который ведет HTC U11 . Но, например, на «древнем» Huawei U8650 ( Android 2.3.4) dumpsys отрабатывает нормально: А прав не хватает для… grep :-) Мониторинг доступа к микрофону Аналогичный метод можно применить и для мониторинга за доступом приложений к микрофону. В этом случае необходимо следить за сервисом media.audio_flinger . Вводим в «шелле» команду (приведенный код работает смартфоне Huawei SCL-L01 ( Android 5.1.1)): while true ; do ps ` while ! (dumpsys media.audio_flinger | grep -A20 Input| grep -A1 Client | grep yes | grep -o "[^yes ].*" | grep -o [0-9]*) do done ` | grep -o "[^S ]*$" | grep -v "NAME" | grep .; date; sleep 1; done Если какое-то приложение записывает звук посредством микрофона, то в выводе dumpsys media.audio_flinger присутствует подобный фрагмент: ( Input thread — входной поток, 22467 — PID записывающего звук процесса). При записи звука через стандартное приложение «Диктофон» и включенном мониторинге (посредством вышеприведенного кода) появляются соответствующие сообщения: А вот какие сообщения сыпятся при активированном голосовом вводе Google переводчика: На других моделях смартфонов формат вывода dumpsys может отличаться, что потребует коррекции кода. Например, на смартфоне Huawei G700-U20 ( Android 4.2.1): В этом случае код для мониторинга будет иметь вид: while true ; do ps ` while ! (dumpsys media.audio_flinger | grep -A3 Input| grep -A1 Clien | grep -o "[^ ].*" | grep -o [0-9]*) do done ` | grep -o "[^S ]*$" | grep -v "NAME" | grep .; date; sleep 1; done Вот как в этом случае проявляет себя «ожившая» Алиса: ]]></text></doc>