<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/post/429252/]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Информационная безопасность]]></category>
  <author auto="true" type="str" verify="true"><![CDATA[Skif_1993]]></author>
  <title auto="true" type="str" verify="true"><![CDATA[Статический анализ мобильных приложений]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Информационная безопасность]]></item>
    <item type="str"><![CDATA[Разработка мобильных приложений]]></item>
    <item type="str"><![CDATA[Аналитика мобильных приложений]]></item>
  </keywords>
  <text auto="true" type="str" verify="true"><![CDATA[ Одним из этапов тестирования мобильного приложения — это статический анализ. Статический анализ приложения — это анализ приложения без выполнения каких либо функций приложения. Наиболее удобным для меня из open source фреймворков есть MobSF. Кому интересно, добро пожаловать под кат. MobSF выполняет статический анализ приложений: Android, Apple iOS и Windows Phone и динамический анализ: только приложения для Android. Как проводить динамический анализ расскажу в следующей статье посвящённой MobSF. Более подробное описание и мануал по установке можно прочитать по ссылке . После установки MobSF — выполним следующий батничек для запуска сервера (писал для себя, поэтому диск D). d: cd .\MobSF\python .\manage.py runserver Дальше нужно перейтипо адресу http[:]//127.0.0.1:8000 и открывается главная страница(Рис. 1). Здесь функционала не много: загрузка файла; просмотреть отчеты по прошедшим сканам; переход на документацию API; переход на GitHub проекта. Рис. 1. Главная страница После того как файл был загружен и проанализирован, появляется страница с результатом анализа (Рис. 2). Слева меню, которое позволит переходить быстро по всей странице (результат объёмный просто). Какая полезная информация находится на этом скриншоте: хэш-сумма приложения; поддерживаемые версии OS Android; количество и типы компонентов (экспортированный или нет), это важно, так как экспортированные компоненты могут привести к критическим уязвимостям; возможность просмотреть и скачать java- и smali-файлы, которые можно проанализировать другими инструментами или вручную; просмотреть файл манифеста, для анализа. Рис. 2. Результат анализа Идем далее. На рис. 3 показана информация по сертификату, которым было подписано приложение. Рис. 3. Информация о сертификате Далее идёт описание анализа permissions, которые описаны в файле AndroidManifest.xml (Рис. 4). MobSF анализирует permissions приложения, определяет его статус, на предмет критичности и описание permissions. Здесь нужно понимать архитектуру OS Android для действительной критичности приложения. Рис. 4. Анализ Android Permissions На вкладке Security Analysis -> Code Analysis (Рис. 5) показывается результат анализа java-кода статическим анализатором, который определяет потенциальные уязвимости, определяет их критичность и файлы в которых этот тип уязвимости был найден. Во многом эти результаты является являются false positive, но нужно это всё перепроверять. Рис. 5. Анализ кода Следующая вкладка (Рис. 6) — это анализ файлов, на сервисе virustotal.com. В данном случае файл не определялся как заражённый. Рис. 6. Анализ файла Вкладка URLs (Рис. 7) выводит список URL-адресов, IP-адресов и файлов в которых они хранятся или вызываются. В этом разделе анализируются куда приложение отправляет данные или куда сохраняет информацию. Рис. 7. Вкладка URLs Вкладка “Strings” (Рис. 8) проводит анализ текстовых файлов, которые находятся в директории res. При анализе приложения эти файлы могут содержать захардкодженые учетки и другие чувствительные данные. Хотя на моей памяти такого не было. Рис. 8. Анализ текстовых файлов Вкладка “Components” (Рис. 9) выводит полный список компонентов (activity, service, content provider и receives), импортированные библиотеки и файлы без определения расширения. Рис. 9. Список компонентов Дополнительно анализ исходного кода можно провести с помощью статического анализатора VCG scanner. Для VCG нужен исходный код. Исходный код можно загрузить через кнопку Download Java Code (Рис. 10). Файл скачивается в ZIP-архиве. Дальше нужно извлечь папку с файлами из архива (Рис. 11). Рис. 10. Скачивание исходного кода Рис. 11. Извлечение исходного кода Сканирование исходного кода делается следующим образом: Во вкладке “Settings” выбираем пункт “Java” — рисунок 12. Во вкладке “File” выбираем “New Target Directory” — рисунок 13. Во вкладке “Scan” выбираем “Full scan” — рисунок 14. Рис. 12. Выбор исходного кода Рис. 13. Подгрузка директории с файлами Рис. 14. Запуск сканирования После завершения сканирования сканер выдаёт названия уязвимости, её критичность, краткое описание и место в исходном коде (Рис. 15). Можно получить полный список уязвимостей и сортировать по их критичности (Рис. 16). Рис. 15. Описание уязвимостей Рис. 16. Полный список уязвимостей Вывод Статический анализ приложения и исходного кода даёт базовые понятия об архитектуре приложения и потенциальных векторов атак. Согласно методологии применяемой в компании Hacken именно с него начинается анализ любых приложений от клиента пришедших на пентест.]]></text>
</doc>
