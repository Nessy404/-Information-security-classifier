<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/company/solarsecurity/blog/424801/]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Информационная безопасность]]></category>
  <author auto="true" type="str" verify="true"><![CDATA[KirillGorshkov]]></author>
  <title auto="true" type="str" verify="true"><![CDATA[Zeppelin OS — ещё один шаг к безопасным смарт-контрактам]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Блог компании Ростелеком-Solar]]></item>
    <item type="str"><![CDATA[Информационная безопасность]]></item>
  </keywords>
  <text auto="true" type="str" verify="true"><![CDATA[Ethereum сейчас одна из самых популярных платформ для создания децентрализованных приложений, которая активно развивается. Одно из новшеств Zeppelin мы сегодня попробуем своими руками. А для тех кто в «танке», Zeppelin — это компания, занимающаяся разработкой и проверкой безопасности смарт-контрактов. Библиотека смарт-контрактов OpenZeppelin их самый известный продукт. Так вышло, что инструменты разработки для Solidity ещё только развиваются, порой не позволяя разработчикам использовать всю мощь технологии смарт-контрактов. Например, ограничением являются «стандартные библиотеки», так как каждый раз в сеть перезаливается уже существующий код, что приводит к увеличению стоимости «развёртывания» кода и количества потенциальных ошибок. Всё это ведёт к существенным ограничениям в создании больших и многофункциональных децентрализованных приложений. Какой такой zeppelin OS? Zeppelin OS — это open source платформа, состоящая из инструментов и сервисов над EVM, предназначенная разработки и управления децентрализованными приложениями. Команда Zeppelin выделила четыре наиболее важные компоненты, часть из которых уже реализована и доступна для использования. Zeppelin OS Kernel — обновляемое и управляемое сообществом «ядро» платформы. Состоит из набора библиотек в блокчейне, которые разработчики могут подключить к своим проектам. Первопроходцем стал OpenZeppelin, который уже доступен для использования. Zeppelin OS Scheduler позволит контрактам запрашивать асинхронное исполнение функции, а также даст возможность любому участнику оплачивать расходы по газу, получая за это вознаграждение. Zeppelin OS Marketplace — важная составляющая взаимодействия между контрактами и приложениями, своего рода App Store / Google Play для блокчейна. Позволит использовать другие сервисы для создания более сложных приложений. Zeppelin OS off-chain tools — набор инструментов для работы и анализа децентрализованных приложений. Время пробовать самим! Очень хотелось начать работать с Zeppelin OS, написать первый контракт и обновить его. Проверить, так ли всё на самом деле и не обманули ли разработчики. Поэтому, оставив устройство обновляемого хранилища и прокси для будущих статей, перейдем к уже реализованному функционалу. Всю документацию Zeppelin OS можно посмотреть тут . Для начала нужно установить zos: $ npm install --global zos Теперь создадим директорию проекта и все необходимое для него: $ mkdir zostest && cd zostest$ npm init$ zos init zostest После чего будут созданы все необходимые конфигурационные файлы, так что теперь можно переходить к написанию контрактов. В качестве тестового контракта давайте напишем небольшое «хранилище переменных»: pragma solidity 0.4 .24 ; import "zos-lib/contracts/migrations/Migratable.sol" ;contract SimpleStorage is Migratable { uint storedData; function initialize ( uint256 _x ) isInitializer ( "SimpleStorage" , "0" ) public { storedData = _x; } function get ( ) public constant returns ( uint ) { return storedData; }} Компилируем и добавляем наш контракт: $ zos add SimpleStorage Запускаем тестовую сеть (в отдельном терминале): $ npx ganache-cli --port 9545 Пушим в нашу локальную сеть, при этом создается новый конфигурационный файл zos.local.json : $ zos push --network local Дело за малым, осталось создать наш обновляемый контракт, попутно запустить initialize() с аргументом 88 для нашего «хранилища»: $ zos create SimpleStorage --init initialize --args 88 --network local Теперь попробуем добавить функцию увеличения переменной в «хранилище», например, такую: pragma solidity 0.4 .24 ; import "zos-lib/contracts/migrations/Migratable.sol" ;contract SimpleStorage is Migratable { uint storedData; function initialize ( uint256 _x ) isInitializer ( "SimpleStorage" , "0" ) public { storedData = _x; } function incrementStorage ( uint256 _x ) public { storedData += _x; } function get ( ) public constant returns ( uint ) { return storedData; }} После чего надо обновить контракт в сети: $ zos push --network local $ zos update SimpleStorage --network local Теперь можно посмотреть, что же вышло. Для этого воспользуемся truffle console : $ npx truffle console --network= local truffle( local )> sS = SimpleStorage.at(<proxy-address>) А <proxy-address> можно посмотреть в zos.local.json в соответствующей графе, и проверим, что там у нас лежит в «хранилище» и можем ли мы увеличивать переменную: Всё работает здорово, есть много возможностей для тестирования контрактов. Я бы сказал, что Zeppelin OS можно использовать, как инструмент разработки точно. Что же мы наделали? Мы проверили, что с помощью Zeppelin OS можно деплоить, обновлять, компилировать и тестировать контракты. Кажется, это отличный инструмент для тех, кому нравится работать с командной строкой, а от Remix в браузере бросает в дрожь. Плюс можно рекомендовать начать знакомство с Solidity и смарт-контрактами именно с этого проекта.]]></text>
</doc>
