<doc>
  <source auto="true" type="str" verify="true"><![CDATA[https://habr.com/ru/company/globalsign/blog/435476/]]></source>
  <category auto="true" type="str" verify="true"><![CDATA[Информационная безопасность]]></category>
  <author auto="true" type="str" verify="true"><![CDATA[GlobalSign_admin]]></author>
  <title auto="true" type="str" verify="true"><![CDATA[Mkcert: валидные HTTPS-сертификаты для localhost]]></title>
  <keywords auto="true" type="list" verify="true">
    <item type="str"><![CDATA[Блог компании GlobalSign]]></item>
    <item type="str"><![CDATA[Информационная безопасность]]></item>
    <item type="str"><![CDATA[Разработка веб-сайтов]]></item>
    <item type="str"><![CDATA[Разработка мобильных приложений]]></item>
    <item type="str"><![CDATA[Микросервисы]]></item>
  </keywords>
  <text auto="true" type="str" verify="true"><![CDATA[В наше время использование HTTPS становится обязательным для всех сайтов и веб-приложений. Но в процессе разработки возникает проблема корректного тестирования. Естественно, Let’s Encrypt и другие CA не выдают сертификаты для localhost. Традиционно есть два решения. Самоподписанные сертификаты, сгенерированные через openssl или др. Вот самый простой способ сгенерировать приватный ключ и самоподписанный сертификат для localhost: openssl req -x509 -out localhost.crt -keyout localhost.key \ -newkey rsa:2048 -nodes -sha256 \ -subj '/CN=localhost' -extensions EXT -config <( \ printf "[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth" ) Но такой сертификат вызовет ошибки доверия в браузерах, потому что в доверенном хранилище отсутствует соответствующий центр сертификации. Трюк с регистрацией нового домена типа localhost.example.com, который локально ресолвится в 127.0.0.1 (в /etc/hosts), с получением обычного сертификата для данного домена. Но такая махинация сомнительна с точки зрения безопасности — по крайней мере, для публичных сервисов подобный ресолвинг делать крайне не рекомендуется из-за возможной MiTM-атаки со сменой на враждебный IP-адрес. Если ограничиться только локальной машиной, то может это и подходящий вариант, хотя тоже возникают некоторые сомнения. К тому же, такой сертификат могут отозвать. В любом случае, есть вариант проще и безопаснее (см. ниже). Речь идёт о mkcert — простой утилите для генерации локально-доверенных сертификатов с собственным центром сертификации . Она работает под всеми ОС и не требует какой-то конфигурации. Версия для Linux Сначала нужно установить certutil . sudo apt install libnss3-tools -или-sudo yum install nss-tools -или-sudo pacman -S nss затем brew install mkcert или собрать из исходников: go get -u github.com/FiloSottile/mkcert$(go env GOPATH)/bin/mkcert Версия для macOS brew install mkcertbrew install nss # if you use Firefox Версия для Windows Под Windows можно скачать собранные бинарники либо воспользоваться одним из пакетных менеджеров: Chocolatey или Scoop. choco install mkcert -или-scoop install mkcert Наличие локального центра сертификации — самое важное принципиальное отличие mkcert от openssl и самоподписанных сертификатов, потому что при запуске такого CA локально не возникает никаких ошибок доверия. В принципе, запустить и настроить собственный CA можно и другими средствами, но это требует нетривиальных знаний и навыков. Здесь всё делает само собой, без всяких дополнительных ключей и настроек. Просто устанавливаем программу — и она автоматически создаёт локальный центр сертификации и прописывает его в доверенное хранилище системы и доверенное хранилище Firefox. $ mkcert -installCreated a new local CA at "/Users/filippo/Library/Application Support/mkcert" The local CA is now installed in the system trust store! ️The local CA is now installed in the Firefox trust store (requires restart)!]]></text>
</doc>
